# frozen_string_literal: true

module Api
  module Crm
    class RemindersController < ApplicationController
      
before_action :set_lead, only: [:index, :create, :update, :update, :update, :update]
      
before_action :set_reminder, only: [:complete, :destroy, :update, :update, :update, :update]

      def index
        reminders = @lead.reminders.order(due_date: :asc)
        render json: reminders.map { |r| reminder_json(r) }, status: :ok
      end

      def create
        reminder_data = extract_reminder_params
        
        reminder = @lead.reminders.build(reminder_data)
        reminder.user_id ||= 1

        if reminder.save
          render json: reminder_json(reminder), status: :created
        else
          render json: { 
            error: 'Failed to create reminder',
            errors: reminder.errors.full_messages 
          }, status: :unprocessable_entity
        end
      rescue => e
        Rails.logger.error "[RemindersController#create] Exception: #{e.message}"
        render json: { 
          error: 'Server error creating reminder',
          message: e.message 
        }, status: :internal_server_error
      end

      def complete
        @reminder.update!(is_completed: true, completed_at: Time.current)
        render json: reminder_json(@reminder), status: :ok
      end

  def update
    data = extract_reminder_params
    if @reminder.update(data)
      render json: reminder_json(@reminder), status: :ok
    else
      render json: { error: "Failed to update reminder", errors: @reminder.errors.full_messages }, status: :unprocessable_entity
    end
  rescue => e
    Rails.logger.error "[RemindersController#update] Exception: #{e.message}"
    render json: { error: "Server error updating reminder", message: e.message }, status: :internal_server_error
  end

      def destroy
        @reminder.destroy!
        head :no_content
      end

      private

      def set_lead
        @lead = Lead.find(params[:lead_id])
      end

      def set_reminder
        @reminder = Reminder.find(params[:id])
      end

      def extract_reminder_params
        if params[:reminder].present?
          data = params[:reminder]
          {
            reminder_type: data[:reminder_type] || data[:type] || 'follow_up',
            title: data[:title],
            description: data[:description],
            due_date: parse_time(data[:due_date]) || (Time.current + 1.day),
            priority: data[:priority] || 'medium',
            is_completed: false,
            user_id: normalize_user_id(data[:user_id])
          }
        else
          {
            reminder_type: params[:type] || params[:reminder_type] || 'follow_up',
            title: params[:title],
            description: params[:description],
            due_date: parse_time(params[:due_date]) || (Time.current + 1.day),
            priority: params[:priority] || 'medium',
            is_completed: false,
            user_id: normalize_user_id(params[:user_id])
          }
        end
      end

      def reminder_json(reminder)
        {
          id: reminder.id,
          leadId: reminder.lead_id,
          userId: reminder.user_id,
          type: reminder.reminder_type,
          title: reminder.title,
          description: reminder.description,
          dueDate: reminder.due_date&.iso8601,
          isCompleted: reminder.is_completed || false,
          priority: reminder.priority,
          createdAt: reminder.created_at&.iso8601,
          updatedAt: reminder.updated_at&.iso8601
        }.compact
      end

      def parse_time(value)
        return nil if value.blank?
        Time.zone.parse(value.to_s)
      rescue
        nil
      end

      def normalize_user_id(value)
        s = value.to_s
        return nil if s.blank? || s == 'current-user'
        (s =~ /^\d+$/) ? s.to_i : nil
      end
    end
  end
end
